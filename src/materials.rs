use rand::random;

use crate::shapes::HitResult;
use crate::types::{Color, Ray, Vector3};

/// Sample a random point in the unit sphere via rejection
fn random_in_unit_sphere() -> Vector3 {
    let offset = Vector3::new(1.0, 1.0, 1.0);
    let mut p: Vector3;
    while {
        p = 2.0 * Vector3::new(random::<f32>(), random::<f32>(), random::<f32>()) - offset;
        p.magnitude_squared() >= 1.0
    } {}

    p
}

/// Generate a reflection ray from a surface with the given normal
fn reflect(v: Vector3, n: Vector3) -> Vector3 {
    v - 2.0 * v.dot(&n) * n
}

/// Generate a refraction ray from a surface with the given and index of refraction
fn refract(v: Vector3, n: Vector3, ni_over_nt: f32) -> Option<Vector3> {
    let uv = v.normalize();
    let dt = uv.dot(&n);
    let discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0 - dt * dt);

    if discriminant > 0.0 {
        let refracted = ni_over_nt * (uv - n * dt) - n * discriminant.sqrt();
        Some(refracted)
    } else {
        None
    }
}

/// Schlick fresnel approximation
fn schlick(cosine: f32, ior: f32) -> f32 {
    let sqrt_r0 = (1.0 - ior) / (1.0 + ior);
    let r0 = sqrt_r0 * sqrt_r0;
    r0 + (1.0 - r0) * (1.0 - cosine).powi(5)
}

/// A ray scattered via interaction with a surface
pub struct ScatteredRay {
    pub ray: Ray,
    pub attenuation: Color,
}

/// Material defines surface properties and generation of scattered rays
pub trait Material: Send + Sync + std::fmt::Debug {
    /// Calculate scattered ray generated by an incoming ray interacting with this surface
    fn scatter(&self, ray: &Ray, hit: &HitResult) -> Option<ScatteredRay>;
}

/// Lambertian material
#[derive(Debug, Clone)]
pub struct Lambertian {
    pub albedo: Color,
}

impl Material for Lambertian {
    /// Calculate scattered ray generated by an incoming ray interacting with this surface
    fn scatter(&self, ray: &Ray, hit: &HitResult) -> Option<ScatteredRay> {
        let _ = ray;
        let target = hit.p.coords + hit.normal + random_in_unit_sphere();
        Some(ScatteredRay {
            ray: Ray::new(hit.p, target - hit.p.coords),
            attenuation: self.albedo,
        })
    }
}

/// Metalic material
#[derive(Debug, Clone)]
pub struct Metal {
    pub albedo: Color,
    pub roughness: f32,
}

impl Material for Metal {
    /// Calculate scattered ray generated by an incoming ray interacting with this surface
    fn scatter(&self, ray: &Ray, hit: &HitResult) -> Option<ScatteredRay> {
        let reflected = reflect(ray.direction.normalize(), hit.normal);
        if reflected.dot(&hit.normal) > 0.0 {
            Some(ScatteredRay {
                ray: Ray::new(hit.p, reflected + self.roughness * random_in_unit_sphere()),
                attenuation: self.albedo,
            })
        } else {
            None
        }
    }
}

/// Dialectric material
#[derive(Debug, Clone)]
pub struct Dialectric {
    pub albedo: Color,
    pub ior: f32,
}

impl Material for Dialectric {
    /// Calculate scattered ray generated by an incoming ray interacting with this surface
    fn scatter(&self, ray: &Ray, hit: &HitResult) -> Option<ScatteredRay> {
        let reflected = reflect(ray.direction, hit.normal);
        let dot = ray.direction.dot(&hit.normal) / ray.direction.magnitude();

        let (outward_normal, ni_over_nt, cosine) = if dot > 0.0 {
            (
                -hit.normal,
                self.ior,
                (1.0 - self.ior * self.ior * (1.0 - dot * dot)).sqrt(),
            )
        } else {
            (hit.normal, 1.0 / self.ior, -dot)
        };

        if let Some(refracted) = refract(ray.direction, outward_normal, ni_over_nt) {
            if random::<f32>() >= schlick(cosine, self.ior) {
                return Some(ScatteredRay {
                    ray: Ray::new(hit.p, refracted),
                    attenuation: self.albedo,
                });
            }
        }

        Some(ScatteredRay {
            ray: Ray::new(hit.p, reflected),
            attenuation: self.albedo,
        })
    }
}
